import io.github.fvarrui.javapackager.gradle.PackageTask
import org.apache.tools.ant.taskdefs.condition.Os
import groovy.json.JsonSlurper

buildscript {
    repositories {
        //mavenLocal()
        /*maven {
            url 'gradlePlugins'
        }*/
        mavenCentral()
    }
    dependencies {
        classpath 'io.github.fvarrui:javapackager:1.4.1'
    }
}

plugins {
    // Apply the java plugin to add support for Java
    id 'java'

    // Plugin to download files
    id "de.undercouch.download" version "4.1.1"
}

apply plugin: 'io.github.fvarrui.javapackager.plugin'

// See https://guides.gradle.org/creating-multi-project-builds/

allprojects {
    repositories {
        jcenter()
    }
    group 'edu.louisville.astro.software'
}

repositories {
}

subprojects {
    version = '5.0.0-SNAPSHOT'
}

dependencies {
    // This dependency is used by the application.
    implementation 'com.google.guava:guava:29.0-jre'
    implementation project(':ij')
    implementation project(':Astronomy_')

    // Use JUnit test framework
    testImplementation 'junit:junit:4.13'
}

task createPlugins {
    def plugins = file("$buildDir/plugins")
    outputs.dir plugins
    doLast {
        plugins.mkdirs()
        new File(plugins, 'readme.md').write("test")
    }
}

def jdks = [macos: [version: 0, ext: "zip", name:""],
            linux: [version: 0, ext: "tar.gz", name:""],
            windows: [version: 0, ext: "zip", name:""]]

// TODO arm mac builds if x86 performance isn't good
def createJdks = project.download {
    for (String sys: jdks.keySet()) {
        String url = "https://api.azul.com/zulu/download/community/v1.0/bundles/latest/?" +
                "os=${sys}&arch=x86&hw_bitness=64&bundle_type=jdk&ext=${jdks.get(sys).ext}"
        // Other paramters:
        // &support_term=lts/mts/sts &release_status=ga/ea/both &jdk_version=11
        def meta = new JsonSlurper().parse(new URL(url))
        jdks.get(sys).version = meta.jdk_version[0]
        jdks.get(sys).ext = meta.ext
        jdks.get(sys).name = meta.name
        src meta.url as String
        overwrite false
        dest new File(projectDir, "jres")
    }
}

def commonDist = project.copySpec {
    from(createPlugins) {
        into 'plugins'
    }
    // Copy astronomy_.jar to correct place in distribution
    from(file("${project(':Astronomy_').buildDir}/libs/astronomy_-${project(':Astronomy_').version}.jar")) {
        rename { String name -> return 'Astronomy_.jar' }
        into 'plugins'
    }

    from("${projectDir}/packageFiles/common") {
        into ''
    }

    into('plugins') {
        from(file("${projectDir}/packageFiles/plugins"))
    }

    // Copy ij.jar to correct place in distribution
    from(file("${project(':ij').buildDir}/libs/ij-${project(':ij').version}.jar")) {
        rename { String name -> return 'ij.jar' }
        into ''
    }
}

def unZipJres = project.copySpec {
    for (entry in jdks) {
        if (entry.key == "linux") {
            from(tarTree(resources.gzip(file("${projectDir}/jres/${entry.value.name}")))) {
                into ''
            }
        } else {
            from(zipTree(file("${projectDir}/jres/${entry.value.name}"))) {
                into ''
            }
        }
    }
}

task unZipJresTask(type: Copy) {
    with unZipJres
    into "${projectDir}/jres"
}

task commonFiles(type: Copy) {
    with commonDist
    into "${buildDir}/commonFiles"
    doLast {
        if (Os.isFamily(Os.FAMILY_MAC)) {
            project.exec {
                commandLine('chmod',  'a=rw', "${buildDir}/commonFiles/AstroImageJ.l4j.ini")
            }
        }
    }
}

// Task to copy built jars into a certain folder, for use with testing
task copyBuiltJars(dependsOn: build, type: Copy) {
    group 'AstroImageJ Developement'

    // Copy astronomy_.jar
    from(file("${project(':Astronomy_').buildDir}/libs/astronomy_-${project(':Astronomy_').version}.jar")) {
        rename { String name -> return 'Astronomy_.jar' }
        into ''
    }
    // Copy ij.jar
    from(file("${project(':ij').buildDir}/libs/ij-${project(':ij').version}.jar")) {
        rename { String name -> return 'ij.jar' }
        into ''
    }
    into "${projectDir}/out"
}

task sync(dependsOn: jar, type: Sync) {
    with commonDist
    destinationDir(file("${projectDir}/AIJ-Run"))
}

// Generates a working install directory of AIJ and launches it - make sure to not add it to git!
task aijRun(dependsOn: sync, type: JavaExec) {
    group 'AstroImageJ Developement'

    workingDir(file("${projectDir}/AIJ-Run/"))

    main = "-jar"
    args "${projectDir}/AIJ-Run/ij.jar"

}

javapackager {
    // common configuration
    mainClass = 'ij.ImageJ'
    bundleJre = true
    customizedJre = false
    outputDirectory = file("${buildDir}/distributions")
    additionalResources = file("${buildDir}/commonFiles/").listFiles()
    runnableJar = file("${buildDir}/commonFiles/ij.jar")
    assetsDir = file("${projectDir}/packageFiles/assets")
    name = 'AstroImageJ'
    winConfig.setWrapJar(false) // Don't merge the ij.jar into the exe file
    macConfig.setRelocateJar(false) // Don't place ij.jar in Java/ folder
    winConfig.setDisableDirPage(false) // Let users set install location
    macConfig.setGeneratePkg(false) // Don't generate pkg as it's installation cannot update memory settings
    macConfig.setEntitlements(project.file('packageFiles/aij_entitlements.txt'))
    macConfig.setAppId("AstroImageJ")

    organizationName = "AstroImageJ"
    vmArgs = [] //['-Xmx3000m', '-Xms256m'] // Launch parameters are set in AstroImageJ.l4j.ini
    version = 'dev-x86' // Dummy version to keep it from saying "unspecified"

    // Set to true to enable installer generation. Needs to be on the target OS and needs special tooling
    // See https://github.com/fvarrui/JavaPackager#generated-artifacts
    // In future installer/package signing will be added. TODO sign the packages
    generateInstaller = true
}
task packageAijForLinux(type: PackageTask, dependsOn: [build, unZipJresTask, commonFiles]) {
    group 'AstroImageJ Developement'
    mustRunAfter commonFiles
    platform = io.github.fvarrui.javapackager.model.Platform.linux
    createTarball = true
    jdkPath = file("${projectDir}/jres/${jdks.linux.name.replace("." + jdks.linux.ext, "")}")
}
task packageAijForMac(type: PackageTask, dependsOn: [build, unZipJresTask, commonFiles]) {
    group 'AstroImageJ Developement'
    mustRunAfter commonFiles
    platform = io.github.fvarrui.javapackager.model.Platform.mac
    createZipball = true
    jdkPath = file("${projectDir}/jres/${jdks.macos.name.replace("." + jdks.macos.ext, "")}/zulu-${jdks.macos.version}.jdk/Contents/Home")
}
task packageAijForWindows(type: PackageTask, dependsOn: [build, unZipJresTask, commonFiles]) {
    group 'AstroImageJ Developement'
    mustRunAfter commonFiles
    platform = io.github.fvarrui.javapackager.model.Platform.windows
    createZipball = true
    jdkPath = file("${projectDir}/jres/${jdks.windows.name.replace("." + jdks.windows.ext, "")}")

    vmArgs = [] // Set to nothing so that the ini file will take over

    // build/commonFiles must exist or gradle will fail all tasks.
    // Wrap in the null check to ensure that it doesn't fail
    if (file("${buildDir}/commonFiles/").listFiles() != null) {
        additionalResources = file("${buildDir}/commonFiles/").listFiles() +
                file("${projectDir}/packageFiles/assets/windows/AstroImageJ.l4j.ini")
    }
}
task packageAij(dependsOn: [ packageAijForLinux, packageAijForMac, packageAijForWindows ]) {
    group 'AstroImageJ Developement'

    outputs.upToDateWhen { false }

    doLast { // Cleanup loose files (DMG creation fails since it finds one in assets)
        //project.delete(files("${buildDir}/distributions/assets"))
        //project.delete(files("${buildDir}/distributions/AstroImageJ"))
    }
}