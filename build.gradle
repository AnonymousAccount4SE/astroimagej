import io.github.fvarrui.javapackager.gradle.PackageTask
import org.apache.tools.ant.taskdefs.condition.Os
import groovy.json.JsonSlurper

buildscript {
    repositories {
        //mavenLocal()
        /*maven {
            url 'gradlePlugins'
        }*/
        mavenCentral()
    }
    dependencies {
        classpath 'io.github.fvarrui:javapackager:1.5.1'
    }
}

plugins {
    // Apply the java plugin to add support for Java
    id 'java'

    // Plugin to download files
    id "de.undercouch.download" version "4.1.1"
}

apply plugin: 'io.github.fvarrui.javapackager.plugin'

// See https://guides.gradle.org/creating-multi-project-builds/

allprojects {
    repositories {
        jcenter()
    }
    group 'edu.louisville.astro.software'

    java {
        toolchain {
            // Gradle will download the JDK for compiling/running if one isn't found
            // This should prevent anyone from using an outdated JDK
            languageVersion.set(JavaLanguageVersion.of(15))
        }
    }
}

subprojects {
    version = '5.0.0-SNAPSHOT'
}

dependencies {
    // This dependency is used by the application.
    //implementation 'com.google.guava:guava:29.0-jre'
    implementation project(':ij')
    implementation project(':Astronomy_')

    // Use JUnit test framework
    //testImplementation 'junit:junit:4.13'
}

/**
 * The set of Java runtimes to download and package AIJ for.
 * Terms in the map are based on the query parameters.
 * To add a distribution, simply give it a unique name and fill out its map with the proper values.
 * See https://app.swaggerhub.com/apis-docs/azul/zulu-download-community/1.0#/bundles/get_bundles_latest_
 *
 * The file's name (name), major Java version (version), and MD5 hash (md5) are also added to this map. Those entries
 * are excluded from the definition for brevity.
 */
def javaRuntimeSystems = [ mac: [ext: "zip", type: "jre", arch: "x86", os: "macos"]
            // JDK is used as Azul has not produced a jre for arm macs at this time
           , armMac: [ext: "zip", type: "jdk", arch: "arm", os: "macos"]
           , linux: [ext: "tar.gz", type: "jre", arch: "x86", os: "linux"]
           , windows: [ext: "zip", type: "jre", arch: "x86", os: "windows"]
           ]

/**
 * Download the specified Java runtimes based on javaRuntimeSystems.
 */
task downloadJavaRuntimes(type: Download) {
    mkdir(file("${projectDir}/jres"))

    javaRuntimeSystems.each {sys, sysInfo ->
        // Other parameters of note:
        // &support_term=lts/mts/sts &release_status=ga/ea/both &jdk_version=11
        String url ="https://api.azul.com/zulu/download/community/v1.0/bundles/latest/?" +
                "os=${sysInfo.os}&arch=${sysInfo.arch}&hw_bitness=64&bundle_type=${sysInfo.type}" +
                "&ext=${sysInfo.ext}"
        def meta = new JsonSlurper().parse(new URL(url)) // Pull the data from Azul

        // Update the maps with the metadata
        sysInfo.version = meta.jdk_version.first()
        sysInfo.ext = meta.ext as String
        sysInfo.name = meta.name as String
        sysInfo.md5 = meta.md5_hash as String

        // Perform the download
        //noinspection GroovyAssignabilityCheck
        src meta.url
        //noinspection GroovyAssignabilityCheck
        overwrite false
        //noinspection GroovyAssignabilityCheck
        dest 'jres'
    }

    // Collect current runtime files and extensions
    def currentFiles = javaRuntimeSystems.collectEntries {[it.value.name, it.value.ext]}

    // Remove old unpacked runtimes
    file("${projectDir}/jres").traverse(type: groovy.io.FileType.DIRECTORIES, maxDepth: 0) {
        if (!currentFiles.collect {name, ext ->
            (name as String).replace("." + ext as String, "")}.contains(it.name)) {
            it.deleteDir()
        }
    }

    // Remove old packed runtimes
    file("${projectDir}/jres").traverse(type: groovy.io.FileType.FILES, maxDepth: 0) {
        if (!currentFiles.containsKey(it.name)) {
            it.delete()
        }
    }

}

/**
 * Verify the downloaded Java runtimes are correct.
 * If a file fails the check, delete it and rerun to attempt downloading again.
 * Could also check the sha256_hash.
 */
task verifyDownloadedJres(type: Verify, dependsOn: downloadJavaRuntimes) {
    mustRunAfter downloadJavaRuntimes
    javaRuntimeSystems.each {sys, sysInfo ->
        //noinspection GroovyAssignabilityCheck
        src file("${projectDir}/jres/${sysInfo.name}")
        //noinspection GroovyAssignabilityCheck
        algorithm 'MD5'
        //noinspection GroovyAssignabilityCheck
        checksum sysInfo.md5
    }
}

/**
 * Decompress the Java runtimes into folders.
 */
task unZipJresTask(type: Copy, dependsOn: verifyDownloadedJres) {
    group 'AstroImageJ Developement'
    mustRunAfter verifyDownloadedJres
    javaRuntimeSystems.each {sys, sysInfo ->
        if (sysInfo.ext == "tar.gz") {
            from(tarTree(resources.gzip(file("${projectDir}/jres/${sysInfo.name}")))) {
                into ''
            }
        } else if (sysInfo.ext == "zip") {
            from(zipTree(file("${projectDir}/jres/${sysInfo.name}"))) {
                into ''
            }
        } else {
            logger.error("Did not know how to handle " + sysInfo.ext + " for " + sys)
        }
    }
    into 'jres'
}

// Define what files belong to all distributions and their location
def commonDist = project.copySpec {
    // Copy astronomy_.jar to correct place in distribution
    from(file("${project(':Astronomy_').buildDir}/libs/astronomy_-${project(':Astronomy_').version}.jar")) {
        rename { String name -> return 'Astronomy_.jar' }
        into 'plugins'
    }

    from("${projectDir}/packageFiles/common") {
        into ''
    }

    into('plugins') {
        from(file("${projectDir}/packageFiles/plugins"))
    }

    // Copy ij.jar to correct place in distribution
    from(file("${project(':ij').buildDir}/libs/ij-${project(':ij').version}.jar")) {
        rename { String name -> return 'ij.jar' }
        into ''
    }
}

// Create commonFiles directory for use in runAij and distribution generation
project.copy {
    with commonDist
    into "${buildDir}/commonFiles"
    if (Os.isFamily(Os.FAMILY_MAC)) {
        project.exec {
            commandLine('chmod',  'a=rw', "${buildDir}/commonFiles/AstroImageJ.l4j.ini")
        }
    }
}

/**
 * Copy the common files into the build directory to simplify their use.
 *
 * This is run when building a distribution to refresh the files in case of a change.
 */
task commonFiles(type: Copy) {
    with commonDist
    into "${buildDir}/commonFiles"
    doLast {
        if (Os.isFamily(Os.FAMILY_MAC)) {
            project.exec {
                commandLine('chmod',  'a=rw', "${buildDir}/commonFiles/AstroImageJ.l4j.ini")
            }
        }
    }
}

// Generate AIJ-Run directory and set it up for usage
task sync(dependsOn: jar, type: Sync) {
    with commonDist
    destinationDir(file("${projectDir}/AIJ-Run"))
}

// Generates a working install directory of AIJ and launches it - make sure to not add it to git!
task aijRun(dependsOn: sync, type: JavaExec) {
    group 'AstroImageJ Developement'

    workingDir(file("${projectDir}/AIJ-Run/"))

    setAllJvmArgs(readConfigFile())

    main = "-jar"
    args "${projectDir}/AIJ-Run/ij.jar"
}

List<String> readConfigFile() {
    List<String> args = new ArrayList<>()
    File cfg = files("${projectDir}/AIJ-Run/AstroImageJ.l4j.ini").first()
    if (!cfg.exists()) return args

    cfg.readLines().each {
        if (it.startsWith("#") /*Comments*/) {
            return
        }
        it.split(" ").each {// Technically this could break, but not expecting too many args in dev environment
            args.add(it)
        }
    }

    return args
}

//suppress access
javapackager {
    // common configuration
    mainClass 'ij.ImageJ'
    bundleJre true
    customizedJre false
    outputDirectory file("${buildDir}/distributions")
    additionalResources file("${buildDir}/commonFiles/").listFiles().toList()
    runnableJar  file("${buildDir}/commonFiles/ij.jar")
    assetsDir  file("${projectDir}/packageFiles/assets")
    name  'AstroImageJ'
    winConfig.setWrapJar(false) // Don't merge the ij.jar into the exe file
    macConfig.setRelocateJar(false) // Don't place ij.jar in Java/ folder
    winConfig.setDisableDirPage(false) // Let users set install location
    macConfig.setGeneratePkg(false) // Don't generate pkg as it's installation cannot update memory settings
    macConfig.setEntitlements(project.file('packageFiles/aij_entitlements.txt'))
    macConfig.setAppId("AstroImageJ")

    organizationName  "AstroImageJ"
    vmArgs  [] //['-Xmx3000m', '-Xms256m'] // Launch parameters are set in AstroImageJ.l4j.ini
    version = 'dev-x86' // Dummy version to keep it from saying "unspecified"

    // Set to true to enable installer generation. Needs to be on the target OS and needs special tooling
    // See https://github.com/fvarrui/JavaPackager#generated-artifacts
    // In future installer/package signing will be added. TODO sign the packages
    generateInstaller  true
}

task packageAij

javaRuntimeSystems.each {sys, sysInfo ->
    String taskName = "packageAijFor" + (sysInfo.os as String).capitalize() + "_" + sysInfo.arch

    tasks.register(taskName, PackageTask) {
        group 'AstroImageJ Developement'

        //noinspection GroovyAssignabilityCheck
        version = sysInfo.arch + "_64" // All AIJ builds are 64 bit
        // Set the platform
        io.github.fvarrui.javapackager.model.Platform.values().each {
            if (it == io.github.fvarrui.javapackager.model.Platform.auto) return
            String osName = sys.toLowerCase().contains("mac") ? "mac" : sys.toLowerCase()
            if (it.name() == osName) {
                //noinspection GroovyAssignabilityCheck
                platform = it
            }
        }

        // Get Java bin fold location
        File runtimePath
        File java = file("${projectDir}/jres/${(sysInfo.name as String).replace("." +sysInfo.ext as String, "")}")
        if (java.exists()) {
            java.traverse(type: groovy.io.FileType.FILES, nameFilter: 'release') {runtimePath = it.parentFile}
        } else { // One of the runtimes does not exist, pull it
            logger.error("A JRE was missing, run unZipJresTask first! " + sys +
                    " will not have a JRE bundled!")
        }

        // Sanity check
        if (runtimePath == null) return

        // Set the runtime
        if (sysInfo.type == "jre") {
            //noinspection GroovyAssignabilityCheck
            jrePath = runtimePath
        } else if (sysInfo.type == "jdk") {
            //noinspection GroovyAssignabilityCheck
            jdkPath = runtimePath
        }

        if (sysInfo.os == "linux") {
            //noinspection GroovyAssignabilityCheck
            createTarball = true
        } else {
            //noinspection GroovyAssignabilityCheck
            createZipball = true
        }
    }

    logger.lifecycle("Added a distribution task: " + taskName)

    tasks.named(taskName) {
        //noinspection GroovyAssignabilityCheck
        dependsOn 'build', 'unZipJresTask', 'commonFiles'
        //noinspection GroovyAssignabilityCheck
        mustRunAfter commonFiles, 'unZipJresTask'
    }

    // Make the meta task run the smaller ones
    tasks.named("packageAij") {
        group 'AstroImageJ Developement'
        //noinspection GroovyAssignabilityCheck
        dependsOn taskName
        outputs.upToDateWhen { false }
    }
}

// Task to copy built jars into a certain folder, for use with testing
task copyBuiltJars(dependsOn: build, type: Copy) {
    group 'AstroImageJ Developement'

    // Copy astronomy_.jar
    from(file("${project(':Astronomy_').buildDir}/libs/astronomy_-${project(':Astronomy_').version}.jar")) {
        rename { String name -> return 'Astronomy_.jar' }
        into ''
    }
    // Copy ij.jar
    from(file("${project(':ij').buildDir}/libs/ij-${project(':ij').version}.jar")) {
        rename { String name -> return 'ij.jar' }
        into ''
    }
    into "${projectDir}/out"
}